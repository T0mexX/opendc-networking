package org.opendc.simulator.network.components

import org.opendc.simulator.network.flow.NetFlow
import org.opendc.simulator.network.flow.Flow
import org.opendc.simulator.network.flow.FlowId
import org.opendc.simulator.network.utils.Kbps
import org.opendc.simulator.network.utils.OnChangeHandler
import org.opendc.simulator.network.utils.logger
import kotlin.system.measureNanoTime

/**
 * Node you can start a [Flow] from or direct a [Flow] to.
 * Updates the end-to-end data rate for each [NetFlow] it is the receiver of.
 */
internal interface EndPointNode: Node {
    companion object { private val log by logger() }

    /**
     * Keeps track of outgoing [NetFlow].
     */
    val outgoingEtoEFlows: MutableMap<FlowId, NetFlow>

    /**
     * Keeps track of incoming [NetFlow].
     */
    val incomingEtoEFlows: MutableMap<FlowId, NetFlow>

    /**
     * Starts a [NetFlow] from ***this*** node.
     * @param[etoEFlow]  the [NetFlow] to be started.
     */
    fun startFlow(etoEFlow: NetFlow) {
        if (etoEFlow.transmitterId != this.id) {
            log.error("unable to start flow, this node is not the sender, aborting...")
            return
        }

        // sets up the handler of any data rate changes, propagating updates to other nodes
        // changes of this flow data rate can be performed through a NetworkController,
        // the NetNodeInterface of this node, or through the instance of the NetFlow itself.
        etoEFlow.withDesiredDataRateOnChangeHandler { _, old, new ->
//            println( "datarate change: ${ measureNanoTime {
            if (old == new) return@withDesiredDataRateOnChangeHandler

            if (new < 0) log.warn("unable to change generated flow with id '${etoEFlow.id}' " +
                "data-rate to $new, data-rate should be positive. Falling back to 0")

            forwardingPolicy.forwardFlow(forwarder = this, flowId = etoEFlow.id)
//            } }" )
        }


        outgoingEtoEFlows[etoEFlow.id] = etoEFlow

        // forwards this flow according to the active forwarding policy
        forwardingPolicy.forwardFlow(forwarder = this, etoEFlow.id)
    }

    /**
     * Stops [etoEFlow] if it is generated by ***this***. Else logs error.
     */
    fun stopFlow(etoEFlow: NetFlow) {
        outgoingEtoEFlows.remove(etoEFlow.id)
            ?. also { updateAllFlows() }
            ?: log.error("unable to stop flow with id ${etoEFlow.id}," +
                " flow is not generated by this node")
    }

    /**
     * Stores a reference to an incoming [NetFlow] so that its end-to-end data rate can be updated.
     * @param[netEtoEFlow]  the [NetFlow] to store the reference of.
     */
    fun addReceivingEtoEFlow(netEtoEFlow: NetFlow) {
        incomingEtoEFlows[netEtoEFlow.id] = netEtoEFlow
    }

    /**
     * Removes the reference of an incoming [NetFlow]. To be called when the end-to-end
     * flow is no longer running through the network.
     * @param[flowId]   id of the end-to-end flow whose reference is to be removed.
     */
    fun rmReceivingEtoEFlow(flowId: FlowId) {
        incomingEtoEFlows.remove(flowId)
            ?: log.error("unable to remove end-to-end receiving flow, flow not present")
    }


    override fun notifyFlowChange(flowId: FlowId) {
        incomingEtoEFlows[flowId]?. let { updateEndToEndFlowDataRate(flowId) }
            ?: let { super<Node>.notifyFlowChange(flowId) }
    }

    override fun totDataRateOf(flowId: FlowId): Kbps =
        super<Node>.totDataRateOf(flowId) + (outgoingEtoEFlows[flowId]?.desiredDataRate ?: .0)

    /**
     * Updates the end-to-end data rate of a [NetFlow] if the flow is expected to be received, else throws error.
     * @param[endToEndFlowId]   the id of the [NetFlow] to update the data rate of.
     */
    private fun updateEndToEndFlowDataRate(endToEndFlowId: FlowId) {
        val endToEndFlow: NetFlow = incomingEtoEFlows[endToEndFlowId] ?: throw IllegalArgumentException()
    }
}
