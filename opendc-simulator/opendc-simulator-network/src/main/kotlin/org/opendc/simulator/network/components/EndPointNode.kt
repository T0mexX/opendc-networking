package org.opendc.simulator.network.components

import org.opendc.simulator.network.flow.EndToEndFlow
import org.opendc.simulator.network.flow.Flow
import org.opendc.simulator.network.flow.FlowId
import org.opendc.simulator.network.utils.Kbps
import org.opendc.simulator.network.utils.logger

/**
 * Node you can start a [Flow] from or direct a [Flow] to.
 * Updates the end-to-end data rate for each [EndToEndFlow] it is the receiver of.
 */
internal interface EndPointNode: Node {
    companion object { private val log by logger() }

    /**
     * Keeps track of outgoing [EndToEndFlow].
     */
    val outgoingEtoEFlows: MutableMap<NodeId, EndToEndFlow>

    /**
     * Keeps track of incoming [EndToEndFlow].
     */
    val incomingEtoEFlows: MutableMap<NodeId, EndToEndFlow>


    /**
     * Starts a [EndToEndFlow] from ***this*** node.
     * @param[etoEFlow]  the [EndToEndFlow] to be started.
     */
    fun startFlow(etoEFlow: EndToEndFlow) {
        if (etoEFlow.senderId != this.id) {
            log.error("unable to start flow, this node is not the sender, aborting...")
            return
        }

        outgoingEtoEFlows[etoEFlow.flowId] = etoEFlow
        forwardingPolicy.forwardFlow(forwarder = this, etoEFlow.flowId)
    }

    /**
     * Stops [etoEFlow] if it is generated by ***this***. Else logs error.
     */
    fun stopFlow(etoEFlow: EndToEndFlow) {
        outgoingEtoEFlows.remove(etoEFlow.flowId)
            ?. also { updateAllFlows() }
            ?: log.error("unable to stop flow with id ${etoEFlow.flowId}," +
                " flow is not generated by this node")
    }

    /**
     * Stores a reference to an incoming [EndToEndFlow] so that its end-to-end data rate can be updated.
     * @param[netEtoEFlow]  the [EndToEndFlow] to store the reference of.
     */
    fun addReceivingEtoEFlow(netEtoEFlow: EndToEndFlow) {
        incomingEtoEFlows[netEtoEFlow.flowId] = netEtoEFlow
    }

    /**
     * Removes the reference of an incoming [EndToEndFlow]. To be called when the end-to-end
     * flow is no longer running through the network.
     * @param[flowId]   id of the end-to-end flow whose reference is to be removed.
     */
    fun rmReceivingEtoEFlow(flowId: FlowId) {
        incomingEtoEFlows.remove(flowId)
            ?: log.error("unable to remove end-to-end receiving flow, flow not present")
    }


    override fun notifyFlowChange(flowId: FlowId) {
        incomingEtoEFlows[flowId]?. let { updateEndToEndFlowDataRate(flowId) }
            ?: let { super<Node>.notifyFlowChange(flowId) }
    }

    override fun totDataRateOf(flowId: FlowId): Kbps =
        super<Node>.totDataRateOf(flowId) + (outgoingEtoEFlows[flowId]?.desiredDataRate ?: .0)

    /**
     * Updates the end-to-end data rate of a [EndToEndFlow] if the flow is expected to be received, else throws error.
     * @param[endToEndFlowId]   the flowId of the [EndToEndFlow] to update the data rate of.
     */
    private fun updateEndToEndFlowDataRate(endToEndFlowId: FlowId) {
        val endToEndFlow: EndToEndFlow = incomingEtoEFlows[endToEndFlowId] ?: throw IllegalArgumentException()
        endToEndFlow.currDataRate = totDataRateOf(endToEndFlowId)
    }
}
