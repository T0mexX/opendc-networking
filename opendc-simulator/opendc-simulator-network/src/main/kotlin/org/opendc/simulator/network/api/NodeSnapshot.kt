package org.opendc.simulator.network.api

import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import org.opendc.simulator.network.components.Network
import org.opendc.simulator.network.components.Node
import org.opendc.simulator.network.energy.EnergyConsumer
import org.opendc.simulator.network.export.Exportable
import org.opendc.simulator.network.flow.FlowHandler
import org.opendc.simulator.network.flow.OutFlow
import org.opendc.simulator.network.flow.tracker.AllByUnsatisfaction
import org.opendc.simulator.network.units.DataRate
import org.opendc.simulator.network.units.Energy
import org.opendc.simulator.network.units.Power
import org.opendc.simulator.network.utils.fractionToPerc
import org.opendc.simulator.network.utils.roundToIfInRange
import java.time.Instant
import kotlin.system.exitProcess

/**
 * A snapshot containing information of [node] collected at [instant].
 *
 * @property[node]                      the node the snapshot was taken of.
 * @property[instant]                   The [Instant] the [NodeSnapshot] was taken.
 * @property[numIncomingFlows]          The number of flows transiting through the node at the instant the snapshot is taken.
 * @property[numOutgoingFlows]          The number of outgoing flows at the instant the snapshot was taken.
 * @property[numGeneratedFlows]         The number of flows that are being generated by the node at the instant the snapshot was taken.
 * @property[numConsumedFlows]          The number of flows that are being consumed by the node at the instant the snapshot was taken.
 * @property[currMinFlowTputPerc]       The lowest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currMaxFlowTputPerc]       The highest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currAvrgFlowTputPerc]      The average throughput percentage of all the flows transiting through the node at the instant the snapshot was taken.
 * @property[currNodePortUsageAllPorts] The utilization of all ports of the node at the instant the snapshot was taken, as the sum of used bws divided by the sum of the max bws.
 * @property[avrgPwrUseOverTime]        The average power usage of the node, from the instant the node was started until the instant the snapshot was taken.
 * @property[currPwrUse]                The power usage at the instant the snapshot was taken.
 * @property[totEnConsumed]             The energy consumed from the instant the node was started until the instant the snapshot was taken.
 * @property[currNodeTputAllFlows]      The total data-rate transiting through the node at the instant the snapshot was taken.
 * @property[currNodeTputPercAllFlows]  The total throughput percentage of all flows transiting through the node at the instant the snapshot was taken.
 *
 */
public class NodeSnapshot internal constructor(
    internal val node: Node,
    public val instant: Instant,
    public val numIncomingFlows: Int,
    public val numOutgoingFlows: Int,
    public val numGeneratedFlows: Int,
    public val numConsumedFlows: Int,
    public val currMinFlowTputPerc: Double?,
    public val currMaxFlowTputPerc: Double?,
    public val currAvrgFlowTputPerc: Double,
    public val currNodePortUsageAllPorts: Double,
    public val avrgPwrUseOverTime: Power,
    public val currPwrUse: Power,
    public val totEnConsumed: Energy,
    public val currNodeTputAllFlows: DataRate,
    public val currNodeTputPercAllFlows: Double,
): Exportable<NodeSnapshot> {
    public val nodeId: NodeId = node.id

    public fun fmt(flags: Int = ALL): String {

        val firstLine = flags.withFlagSet(HDR, dflt = "") { fmtHdr(flags) }

        val secondLine = buildString {
            append("| ${node.toString().padEnd(COL_WIDTH)}")
            flags.withFlagSet(INSTANT) { append(instant.toString().padEnd(30)) }
            flags.withFlagSet(NUM_FLOWS_IN) { append(numIncomingFlows.toString().padEnd(COL_WIDTH)) }
            flags.withFlagSet(NUM_FLOWS_OUT) { append(numOutgoingFlows.toString().padEnd(COL_WIDTH)) }
            flags.withFlagSet(NUM_GEN_FLOWS) { append(numGeneratedFlows.toString().padEnd(COL_WIDTH)) }
            flags.withFlagSet(NUM_CONS_FLOWS) { append(numConsumedFlows.toString().padEnd(COL_WIDTH)) }
            flags.withFlagSet(MIN_THROUGHPUT_PERC) { append( (  currMinFlowTputPerc?.fractionToPerc("%.2f") ?: "NA"  ).padEnd(COL_WIDTH)) }
            flags.withFlagSet(MAX_THROUGHPUT_PERC) { append( (  currMaxFlowTputPerc?.fractionToPerc("%.2f") ?: "NA"  ).padEnd(COL_WIDTH)) }
            flags.withFlagSet(AVRG_THROUGHPUT_PERC) { append( (  if (numOutgoingFlows == 0) "NA" else currAvrgFlowTputPerc.fractionToPerc("%.2f")  ).padEnd(COL_WIDTH)) }
            flags.withFlagSet(TOT_NODE_THROUGHPUT) { append("${currNodeTputAllFlows.fmtValue("%.5f")} (${currNodeTputPercAllFlows.fractionToPerc("%.1f")})".padEnd(COL_WIDTH)) }
            flags.withFlagSet(TOT_NODE_PORT_USAGE) { append(currNodePortUsageAllPorts.fractionToPerc("%.2f").padEnd(COL_WIDTH)) }
            flags.withFlagSet(CURR_PWR_USE) { append(String.format("%.5f", currPwrUse.toWatts()).padEnd(COL_WIDTH)) }
            flags.withFlagSet(AVRG_PWR_USE) { append(String.format("%.5f", avrgPwrUseOverTime.toWatts()).padEnd(COL_WIDTH)) }
            flags.withFlagSet(TOT_EN_CONSUMPT) { append(String.format("%.5f", totEnConsumed.toWh()).padEnd(COL_WIDTH)) }
        }

        if (currAvrgFlowTputPerc != 1.0 && currAvrgFlowTputPerc.isNaN().not()) {
            println(firstLine + secondLine)
            runBlocking { delay(1000) }
            exitProcess(0)
        }

        return firstLine + secondLine
    }

    public companion object {

        private const val COL_WIDTH = 27

        /**
         * The [Instant] the [NodeSnapshot] was taken.
         */
        public const val INSTANT: Int = 1

        /**
         * The number of flows transiting through the node at the instant the snapshot is taken.
         */
        public const val NUM_FLOWS_IN: Int = 1 shl 1

        /**
         * The number of outgoing flows at the instant the snapshot was taken.
         */
        public const val NUM_FLOWS_OUT: Int = 1 shl 2

        /**
         * The number of flows that are being generated by the node at the instant the snapshot was taken.
         */
        public const val NUM_GEN_FLOWS: Int = 1 shl 3

        /**
         * The number of flows that are being consumed by the node at the instant the snapshot was taken.
         */
        public const val NUM_CONS_FLOWS: Int = 1 shl 4

        /**
         * The lowest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public const val MIN_THROUGHPUT_PERC: Int = 1 shl 5

        /**
         * The highest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public const val MAX_THROUGHPUT_PERC: Int = 1 shl 6

        /**
         * The average throughput percentage of all the flows transiting through
         * the node at the instant the snapshot was taken.
         */
        public const val AVRG_THROUGHPUT_PERC: Int = 1 shl 7

        /**
         * The utilization of all ports of the node at the instant the snapshot was taken,
         * as the sum of used bws divided by the sum of the max bws.
         */
        public const val TOT_NODE_PORT_USAGE: Int = 1 shl 8

        /**
         * The power usage at the instant the snapshot was taken.
         */
        public const val CURR_PWR_USE: Int = 1 shl 9

        /**
         * The average power usage of the node, from the instant the node
         * was started until the instant the snapshot was taken.
         */
        public const val AVRG_PWR_USE: Int = 1 shl 10

        /**
         * The energy consumed from the instant the node was
         * started until the instant the snapshot was taken.
         */
        public const val TOT_EN_CONSUMPT: Int = 1 shl 11

        /**
         * The total data-rate transiting through the node at the instant the snapshot was taken.
         */
        public const val TOT_NODE_THROUGHPUT: Int = 1 shl 14

        /**
         * Flag that adds a line to the formatted snapshot string with the fields headers.
         */
        public const val HDR: Int = 1 shl 15

        /**
         * "Flag" that includes all the other flags.
         */
        public const val ALL: Int = -1

        /**
         * "Flag" that includes all the other flags except [HDR].
         */
        public const val ALL_NO_HDR: Int = -1 and HDR.inv()

        private inline fun <T> Int.withFlagSet(flag: Int, dflt: T? = null, block: () -> T): T? =
            if (this and flag != 0)
                block()
            else dflt

        internal fun Node.snapshot(instant: Instant, withStableNetwork: Network? = null): NodeSnapshot {
            withStableNetwork?.let {
                runBlocking {
                    it.awaitStability()
                    it.validator.checkIsStableWhile { snapshot(instant = instant) }
                }
            }

            val fh: FlowHandler = this.flowHandler
            val flows: List<OutFlow> = fh.nodeFlowTracker[AllByUnsatisfaction]

            val totNodeTput: DataRate = DataRate.ofKbps(flows.sumOf { it.totRateOut.toKbps() })
            return NodeSnapshot(
                node = this,
                instant = instant,
                numIncomingFlows = fh.consumedFlows.size + fh.outgoingFlows.size - fh.generatedFlows.size,
                numOutgoingFlows = fh.outgoingFlows.size,
                numGeneratedFlows = fh.generatedFlows.size,
                numConsumedFlows = fh.consumedFlows.size,
                currMinFlowTputPerc = flows.getOrNull(0)?.tPutPerc(),
                currMaxFlowTputPerc = flows.lastOrNull()?.tPutPerc(),
                currAvrgFlowTputPerc = flows.sumOf { it.tPutPerc() } / flows.size,
                currNodeTputPercAllFlows = flows.sumOf { it.totRateOut.toKbps() } / flows.sumOf { it.demand.toKbps() },
                currPwrUse = (this as? EnergyConsumer<*>)?.enMonitor?.currPwrUsage ?: Power.ZERO,
                avrgPwrUseOverTime = (this as? EnergyConsumer<*>)?.enMonitor?.avrgPwrUsage ?: Power.ZERO,
                totEnConsumed = (this as? EnergyConsumer<*>)?.enMonitor?.totEnConsumpt ?: Energy.ZERO,
                currNodeTputAllFlows = totNodeTput,
                currNodePortUsageAllPorts = totNodeTput / DataRate.ofKbps(ports.sumOf { it.maxSpeed.toKbps() })
            )
        }

        /**
         * @return formatted [String] line containing all the headers
         * of the fields associated with the flags [flags]. The [HDR] flag is ignored.
         */
        public fun fmtHdr(flags: Int = ALL): String =
            buildString {
                append("| " + "node".padEnd(COL_WIDTH))
                flags.withFlagSet(INSTANT) { append("instant".padEnd(30)) }
                flags.withFlagSet(NUM_FLOWS_IN) { append("flows in".padEnd(COL_WIDTH)) }
                flags.withFlagSet(NUM_FLOWS_OUT) { append("flows out".padEnd(COL_WIDTH)) }
                flags.withFlagSet(NUM_GEN_FLOWS) { append("generating n flows".padEnd(COL_WIDTH)) }
                flags.withFlagSet(NUM_CONS_FLOWS) { append("consuming n flows".padEnd(COL_WIDTH)) }
                flags.withFlagSet(MIN_THROUGHPUT_PERC) { append("curr min flow tput %".padEnd(COL_WIDTH)) }
                flags.withFlagSet(MAX_THROUGHPUT_PERC) { append("curr max flow tput %".padEnd(COL_WIDTH)) }
                flags.withFlagSet(AVRG_THROUGHPUT_PERC) { append("curr avrg flow tput %".padEnd(COL_WIDTH)) }
                flags.withFlagSet(TOT_NODE_THROUGHPUT) { append("curr tput (all flows) (%)".padEnd(COL_WIDTH)) }
                flags.withFlagSet(TOT_NODE_PORT_USAGE) { append("curr node port usage %".padEnd(COL_WIDTH)) }
                flags.withFlagSet(CURR_PWR_USE) { append("curr pwr use [Watts]".padEnd(COL_WIDTH)) }
                flags.withFlagSet(AVRG_PWR_USE) { append("avrg pwr over time [Watts]".padEnd(COL_WIDTH)) }
                flags.withFlagSet(TOT_EN_CONSUMPT) { append("tot energy cons [Wh]".padEnd(COL_WIDTH)) }
                appendLine()
            }
    }
}

private fun OutFlow.tPutPerc(): Double =
    (this.totRateOut / this.demand).roundToIfInRange(to = 1.0).let {
        check(it in .0..1.0) { "throughput % should be between 0 and 1 but was ${totRateOut / demand}" }
        it
    }
