package org.opendc.simulator.network.api

import kotlinx.coroutines.runBlocking
import org.opendc.simulator.network.components.Network
import org.opendc.simulator.network.components.Node
import org.opendc.simulator.network.energy.EnergyConsumer
import org.opendc.simulator.network.export.Exportable
import org.opendc.simulator.network.flow.FlowHandler
import org.opendc.simulator.network.flow.OutFlow
import org.opendc.simulator.network.flow.tracker.AllByUnsatisfaction
import org.opendc.simulator.network.units.DataRate
import org.opendc.simulator.network.units.Energy
import org.opendc.simulator.network.units.Power
import org.opendc.simulator.network.utils.ratioToPerc
import org.opendc.simulator.network.utils.roundToIfInRange
import java.time.Instant

/**
 * A snapshot containing information of [node] collected at [instant].
 *
 * @property[node]                      the node the snapshot was taken of.
 * @property[instant]                   The [Instant] the [NodeSnapshot] was taken.
 * @property[numIncomingFlows]          The number of incoming flows at the instant the snapshot is taken.
 * @property[numOutgoingFlows]          The number of outgoing flows at the instant the snapshot was taken.
 * @property[numGeneratedFlows]         The number of flows that are being generated by the node at the instant the snapshot was taken.
 * @property[numConsumedFlows]          The number of flows that are being consumed by the node at the instant the snapshot was taken.
 * @property[currMinFlowTputPerc]       The lowest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currMaxFlowTputPerc]       The highest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currAvrgFlowTputPerc]      The average throughput percentage of all the flows transiting through the node at the instant the snapshot was taken.
 * @property[currNodePortUsageAllPorts] The utilization of all ports of the node at the instant the snapshot was taken, as the sum of used bws divided by the sum of the max bws.
 * @property[avrgPwrUseOverTime]        The average power usage of the node, from the instant the node was started until the instant the snapshot was taken.
 * @property[currPwrUse]                The power usage at the instant the snapshot was taken.
 * @property[totEnConsumed]             The energy consumed from the instant the node was started until the instant the snapshot was taken.
 * @property[currNodeTputAllFlows]      The total data-rate transiting through the node at the instant the snapshot was taken.
 * @property[currNodeTputPercAllFlows]  The total throughput percentage of all flows transiting through the node at the instant the snapshot was taken.
 *
 */
public class NodeSnapshot internal constructor(
    internal val node: Node,
    public val instant: Instant,
    public val numIncomingFlows: Int,
    public val numOutgoingFlows: Int,
    public val numGeneratedFlows: Int,
    public val numConsumedFlows: Int,
    public val currMinFlowTputPerc: Double?,
    public val currMaxFlowTputPerc: Double?,
    public val currAvrgFlowTputPerc: Double,
    public val currNodePortUsageAllPorts: Double,
    public val avrgPwrUseOverTime: Power,
    public val currPwrUse: Power,
    public val totEnConsumed: Energy,
    public val currNodeTputAllFlows: DataRate,
    public val currNodeTputPercAllFlows: Double,
): Exportable<NodeSnapshot> {
    public val nodeId: NodeId = node.id

    /**
     * @param[flags]    flags representing which property
     * need to be included in the formatted string.
     * @return          the formatted string representing the snapshot information,
     * as either 1 or 2 lines with a column for each property.
     */
    public fun fmt(flags: Int = ALL): String {

        val firstLine = flags.ifSet(HDR, dflt = "") { fmtHdr(flags) }

        val secondLine = buildString {
            appendPad("| $node")
            flags.ifSet(INSTANT) { appendPad(instant, pad = 30) }
            flags.ifSet(NUM_FLOWS_IN) { appendPad(numIncomingFlows) }
            flags.ifSet(NUM_FLOWS_OUT) { appendPad(numOutgoingFlows) }
            flags.ifSet(NUM_GEN_FLOWS) { appendPad(numGeneratedFlows) }
            flags.ifSet(NUM_CONS_FLOWS) { appendPad(numConsumedFlows) }
            flags.ifSet(MIN_THROUGHPUT_PERC) { appendPad(currMinFlowTputPerc?.ratioToPerc("%.2f") ?: "NA") }
            flags.ifSet(MAX_THROUGHPUT_PERC) { appendPad(currMaxFlowTputPerc?.ratioToPerc("%.2f") ?: "NA") }
            flags.ifSet(AVRG_THROUGHPUT_PERC) { appendPad(if (numOutgoingFlows == 0) "NA" else currAvrgFlowTputPerc.ratioToPerc("%.2f")) }
            flags.ifSet(TOT_NODE_THROUGHPUT) { appendPad("${currNodeTputAllFlows.fmtValue("%.5f")} (${currNodeTputPercAllFlows.ratioToPerc("%.1f")})") }
            flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad(currNodePortUsageAllPorts.ratioToPerc("%.5f")) }
            flags.ifSet(CURR_PWR_USE) { appendPad(currPwrUse.fmtValue("%.5f")) }
            flags.ifSet(AVRG_PWR_USE) { appendPad(avrgPwrUseOverTime.fmtValue("%.5f")) }
            flags.ifSet(EN_CONSUMED) { appendPad(totEnConsumed.fmtValue("%.5f")) }
        }

        return firstLine + secondLine
    }

    override fun toString(): String = "[NodeSnapshot: id=$nodeId, timestamp=$instant]"

    public companion object {
        private const val COL_WIDTH = 27

        /**
         * The [Instant] the [NodeSnapshot] was taken.
         */
        public const val INSTANT: Int = 1

        /**
         * The number of flows transiting through the node at the instant the snapshot is taken.
         */
        public const val NUM_FLOWS_IN: Int = 1 shl 1

        /**
         * The number of outgoing flows at the instant the snapshot was taken.
         */
        public const val NUM_FLOWS_OUT: Int = 1 shl 2

        /**
         * The number of flows that are being generated by the node at the instant the snapshot was taken.
         */
        public const val NUM_GEN_FLOWS: Int = 1 shl 3

        /**
         * The number of flows that are being consumed by the node at the instant the snapshot was taken.
         */
        public const val NUM_CONS_FLOWS: Int = 1 shl 4

        /**
         * The lowest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public const val MIN_THROUGHPUT_PERC: Int = 1 shl 5

        /**
         * The highest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public const val MAX_THROUGHPUT_PERC: Int = 1 shl 6

        /**
         * The average throughput percentage of all the flows transiting through
         * the node at the instant the snapshot was taken.
         */
        public const val AVRG_THROUGHPUT_PERC: Int = 1 shl 7

        /**
         * The utilization of all ports of the node at the instant the snapshot was taken,
         * as the sum of used bws divided by the sum of the max bws.
         */
        public const val TOT_NODE_PORT_USAGE: Int = 1 shl 8

        /**
         * The power usage at the instant the snapshot was taken.
         */
        public const val CURR_PWR_USE: Int = 1 shl 9

        /**
         * The average power usage of the node, from the instant the node
         * was started until the instant the snapshot was taken.
         */
        public const val AVRG_PWR_USE: Int = 1 shl 10

        /**
         * The energy consumed from the instant the node was
         * started until the instant the snapshot was taken.
         */
        public const val EN_CONSUMED: Int = 1 shl 11

        /**
         * The total data-rate transiting through the node at the instant the snapshot was taken.
         */
        public const val TOT_NODE_THROUGHPUT: Int = 1 shl 14

        /**
         * Flag that adds a line to the formatted snapshot string with the fields headers.
         */
        public const val HDR: Int = 1 shl 15

        /**
         * "Flag" that includes all the other flags.
         */
        public const val ALL: Int = -1

        /**
         * "Flag" that includes all the other flags except [HDR].
         */
        public const val ALL_NO_HDR: Int = -1 and HDR.inv()

        private inline fun <T> Int.ifSet(flag: Int, dflt: T? = null, block: () -> T): T? =
            if (this and flag != 0)
                block()
            else dflt

        internal fun Node.snapshot(instant: Instant, withStableNetwork: Network? = null): NodeSnapshot {
            withStableNetwork?.let {
                runBlocking {
                    it.awaitStability()
                    it.validator.checkIsStableWhile { snapshot(instant = instant) }
                }
            }

            val fh: FlowHandler = this.flowHandler
            val flows: List<OutFlow> = fh.nodeFlowTracker[AllByUnsatisfaction]

            val totNodeTput: DataRate = DataRate.ofKbps(flows.sumOf { it.totRateOut.toKbps() })
            return NodeSnapshot(
                node = this,
                instant = instant,
                numIncomingFlows = fh.consumedFlows.size + fh.outgoingFlows.size - fh.generatedFlows.size,
                numOutgoingFlows = fh.outgoingFlows.size,
                numGeneratedFlows = fh.generatedFlows.size,
                numConsumedFlows = fh.consumedFlows.size,
                currMinFlowTputPerc = flows.getOrNull(0)?.tPutPerc(),
                currMaxFlowTputPerc = flows.lastOrNull()?.tPutPerc(),
                currAvrgFlowTputPerc = flows.sumOf { it.tPutPerc() } / flows.size,
                currNodeTputPercAllFlows = flows.sumOf { it.totRateOut.toKbps() } / flows.sumOf { it.demand.toKbps() },
                currPwrUse = (this as? EnergyConsumer<*>)?.enMonitor?.currPwrUsage ?: Power.ZERO,
                avrgPwrUseOverTime = (this as? EnergyConsumer<*>)?.enMonitor?.avrgPwrUsage ?: Power.ZERO,
                totEnConsumed = (this as? EnergyConsumer<*>)?.enMonitor?.totEnConsumpt ?: Energy.ZERO,
                currNodeTputAllFlows = totNodeTput,
                currNodePortUsageAllPorts = totNodeTput / DataRate.ofKbps(ports.sumOf { it.maxSpeed.toKbps() })
            )
        }

        /**
         * @return formatted [String] line containing all the headers
         * of the fields associated with the flags [flags]. The [HDR] flag is ignored.
         */
        public fun fmtHdr(flags: Int = ALL): String =
            buildString {
                appendPad("| node")
                flags.ifSet(INSTANT) { appendPad("instant", pad = 30) }
                flags.ifSet(NUM_FLOWS_IN) { appendPad("flows in") }
                flags.ifSet(NUM_FLOWS_OUT) { appendPad("flows out") }
                flags.ifSet(NUM_GEN_FLOWS) { appendPad("generating n flows") }
                flags.ifSet(NUM_CONS_FLOWS) { appendPad("consuming n flows") }
                flags.ifSet(MIN_THROUGHPUT_PERC) { appendPad("curr min flow tput %") }
                flags.ifSet(MAX_THROUGHPUT_PERC) { appendPad("curr max flow tput %") }
                flags.ifSet(AVRG_THROUGHPUT_PERC) { appendPad("curr avrg flow tput %") }
                flags.ifSet(TOT_NODE_THROUGHPUT) { appendPad("curr tput (all flows) (%)") }
                flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad("curr node port usage %") }
                flags.ifSet(CURR_PWR_USE) { appendPad("curr pwr use") }
                flags.ifSet(AVRG_PWR_USE) { appendPad("avrg pwr over time") }
                flags.ifSet(EN_CONSUMED) { appendPad("tot energy cons") }
                appendLine()
            }

        private fun StringBuilder.appendPad(obj: Any?, pad: Int = COL_WIDTH) {
            append(obj.toString().padEnd(pad))
        }

        private fun StringBuilder.appendPad(str: String, pad: Int = COL_WIDTH) {
            append(str.padEnd(pad))
        }
    }
}

private fun OutFlow.tPutPerc(): Double =
    (this.totRateOut / this.demand).roundToIfInRange(to = 1.0).let {
        check(it in .0..1.0) { "throughput % should be between 0 and 1 but was ${totRateOut / demand}" }
        it
    }
