package org.opendc.simulator.network.flow

import kotlinx.coroutines.runBlocking
import org.opendc.simulator.network.components.EndPointNode
import org.opendc.simulator.network.api.NodeId
import org.opendc.simulator.network.utils.Kb
import org.opendc.simulator.network.utils.Kbps
import org.opendc.simulator.network.utils.OnChangeHandler
import org.opendc.simulator.network.utils.SuspOnChangeHandler
import org.opendc.simulator.network.utils.ms
import kotlin.properties.Delegates

/**
 * Represents an end-to-end flow, meaning the flow from one [EndPointNode] to another.
 * This end-to-end flow can be split into multiple sub-flows along the path,
 * but ultimately each sub-flow arrives at destination.
 * @param[transmitterId]             id of the [EndPointNode] this end-to-end flow is generated from.
 * @param[destinationId]               id of the [EndPointNode] this end-to-end flow is directed to.
 * @param[id]               id of this end-to-end flow.
 * @param[demand]      data rate generated by the sender.
 */
public class NetFlow(
    public val id: FlowId,
    public val transmitterId: NodeId,
    public val destinationId: NodeId,
    demand: Kbps = .0,
    ) {

    init {
        FlowData.flowsDestIds[id] = destinationId
    }

    private val throughputOnChangeHandlers = mutableListOf<OnChangeHandler<NetFlow, Kbps>>()
    private val demandOnChangeHandlers = mutableListOf<SuspOnChangeHandler<NetFlow, Kbps>>()


    private var totDataTransmitted: Kb = .0


    public var demand: Kbps = demand
        private set

    /**
     * Updates the data rate demand for ***this*** flow.
     * Call observers change handlers, added with [withDemandOnChangeHandler].
     */
    @JvmSynthetic
    public suspend fun setDemandSus(newDemand: Kbps) {
        val oldDemand = demand
        demand = newDemand

        // calls observers handlers
        demandOnChangeHandlers.forEach {
            it.handleChange(this, oldDemand, newDemand)
        }
    }

    /**
     * Non suspending overload for java interoperability.
     */
    public fun setDemand(newDemand: Kbps) { runBlocking { setDemandSus(newDemand) } }

    /**
     * The end-to-end throughput of the flow.
     */
    public var throughput: Kbps by Delegates.observable(.0) { _, old, new ->
        if (old == new) return@observable
        throughputOnChangeHandlers.forEach { it.handleChange(obj = this, oldValue = old, newValue = new) }
    }
    internal set

    public fun withThroughputOnChangeHandler(f: (NetFlow, Kbps, Kbps) -> Unit): NetFlow {
        throughputOnChangeHandlers.add(f)

        return this
    }

    internal fun withDemandOnChangeHandler(f: SuspOnChangeHandler<NetFlow, Kbps>): NetFlow {
        demandOnChangeHandlers.add(f)

        return this
    }

    internal fun advanceBy(ms: ms) {
        fun ms.toSeconds(): Double = this.toDouble() / 1000

        totDataTransmitted += throughput * ms.toSeconds()
    }

    @Suppress("removal")
    protected fun finalize() {
        FlowData.flowsDestIds.remove(this.id)
    }
}


internal typealias FlowId = Int
