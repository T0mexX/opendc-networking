package org.opendc.simulator.network.flow

import org.opendc.simulator.network.components.EndPointNode
import org.opendc.simulator.network.components.NodeId
import org.opendc.simulator.network.utils.Kb
import org.opendc.simulator.network.utils.Kbps
import org.opendc.simulator.network.utils.OnChangeHandler
import org.opendc.simulator.network.utils.SuspOnChangeHandler
import org.opendc.simulator.network.utils.ms
import java.time.Duration
import kotlin.properties.Delegates
import kotlin.system.measureNanoTime

/**
 * Represents an end-to-end flow, meaning the flow from one [EndPointNode] to another.
 * This end-to-end flow can be split into multiple sub-flows along the path,
 * but ultimately each sub-flow arrives at destination.
 * @param[transmitterId]             id of the [EndPointNode] this end-to-end flow is generated from.
 * @param[destinationId]               id of the [EndPointNode] this end-to-end flow is directed to.
 * @param[id]               id of this end-to-end flow.
 * @param[desiredDataRate]      data rate generated by the sender.
 */
public class NetFlow(
    public val id: FlowId,
    public val transmitterId: NodeId,
    public val destinationId: NodeId,
    desiredDataRate: Kbps = .0,
    ) {

    private val throughputOnChangeHandlers = mutableListOf<OnChangeHandler<NetFlow, Kbps>>()
    private val desiredDataRateOnChangeHandlers = mutableListOf<SuspOnChangeHandler<NetFlow, Kbps>>()


    private var totDataTransmitted: Kb = .0


    public var desiredDataRate: Kbps = desiredDataRate
        private set

    // suspending setter
    public suspend fun setDesiredDataRate(newRate: Kbps) {
        val oldRate = desiredDataRate
        desiredDataRate = newRate

        // calls observers handlers
        desiredDataRateOnChangeHandlers.forEach {
            it.handleChange(this, oldRate, newRate)
        }
    }

    /**
     * The end-to-end throughput of the flow.
     */
    public var throughput: Kbps by Delegates.observable(.0) { _, old, new ->
        if (old == new) return@observable
        throughputOnChangeHandlers.forEach { it.handleChange(obj = this, oldValue = old, newValue = new) }
    }
    internal set

    public fun withThroughputOnChangeHandler(f: (NetFlow, Kbps, Kbps) -> Unit): NetFlow {
        throughputOnChangeHandlers.add(f)

        return this
    }

    internal fun withDesiredDataRateOnChangeHandler(f: SuspOnChangeHandler<NetFlow, Kbps>): NetFlow {
        desiredDataRateOnChangeHandlers.add(f)

        return this
    }

    internal fun advanceBy(ms: ms) {
        fun ms.toSeconds(): Double = this.toDouble() / 1000

        totDataTransmitted += throughput * ms.toSeconds()
    }
}


internal typealias FlowId = Int
