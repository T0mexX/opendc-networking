package org.opendc.simulator.network.flow

import org.opendc.simulator.network.components.EndPointNode
import org.opendc.simulator.network.components.NodeId
import org.opendc.simulator.network.utils.Kb
import org.opendc.simulator.network.utils.Kbps
import org.opendc.simulator.network.utils.OnChangeHandler
import org.opendc.simulator.network.utils.ms
import java.time.Duration
import kotlin.properties.Delegates

/**
 * Represents an end-to-end flow, meaning the flow from one [EndPointNode] to another.
 * This end-to-end flow can be split into multiple sub-flows along the path,
 * but ultimately each sub-flow arrives at destination.
 * @param[transmitterId]             id of the [EndPointNode] this end-to-end flow is generated from.
 * @param[destinationId]               id of the [EndPointNode] this end-to-end flow is directed to.
 * @param[id]               id of this end-to-end flow.
 * @param[desiredDataRate]      data rate generated by the sender.
 */
public class NetFlow(
    public val transmitterId: NodeId,
    public val destinationId: NodeId,
    public val id: FlowId,
    desiredDataRate: Kbps = .0,
) {

    private val throughputOnChangeHandlers = mutableListOf<OnChangeHandler<NetFlow, Kbps>>()
    private val desiredDataRateOnChangeHandlers = mutableListOf<OnChangeHandler<NetFlow, Kbps>>()

    private var totDataTransmitted: Kb = .0

    public var desiredDataRate: Kbps by Delegates.observable(desiredDataRate) { _, old, new ->
        if (old == new) return@observable
        desiredDataRateOnChangeHandlers.forEach { it.handleChange(obj = this, oldValue = old, newValue = new) }
    }

    /**
     * The end-to-end throughput of the flow.
     */
    public var throughput: Kbps by Delegates.observable(.0) { _, old, new ->
        if (old == new) return@observable
        throughputOnChangeHandlers.forEach { it.handleChange(obj = this, oldValue = old, newValue = new) }
    }
    internal set

    public fun withThroughputOnChangeHandler(f: (NetFlow, Kbps, Kbps) -> Unit): NetFlow {
        throughputOnChangeHandlers.add(f)

        return this
    }

    internal fun withDesiredDataRateOnChangeHandler(f: OnChangeHandler<NetFlow, Kbps>): NetFlow {
        desiredDataRateOnChangeHandlers.add(f)

        return this
    }

//    /** TODO
//     * Advances time by [timeSpan], adjusting [remDataToTransmit] accordingly.
//     */
    internal fun advanceBy(timeSpan: Duration) {
        advanceBy(timeSpan.toMillis())
    }

    internal fun advanceBy(ms: ms) {
        fun ms.toSeconds(): Double = this.toDouble() / 1000

        totDataTransmitted += throughput * ms.toSeconds()
    }
}



