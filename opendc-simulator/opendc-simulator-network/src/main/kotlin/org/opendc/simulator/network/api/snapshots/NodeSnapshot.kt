/*
 * Copyright (c) 2024 AtLarge Research
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.opendc.simulator.network.api.snapshots

import kotlinx.coroutines.runBlocking
import org.opendc.common.units.DataRate
import org.opendc.common.units.Energy
import org.opendc.common.units.Percentage
import org.opendc.common.units.Power
import org.opendc.common.units.Unit.Companion.sumOfUnit
import org.opendc.simulator.network.api.NetworkController
import org.opendc.simulator.network.api.NodeId
import org.opendc.simulator.network.components.Network
import org.opendc.simulator.network.components.Node
import org.opendc.simulator.network.energy.EnergyConsumer
import org.opendc.simulator.network.flow.FlowHandler
import org.opendc.simulator.network.flow.OutFlow
import org.opendc.simulator.network.flow.tracker.AllByUnsatisfaction
import org.opendc.simulator.network.utils.Flag
import org.opendc.simulator.network.utils.Flags
import org.opendc.trace.util.parquet.exporter.Exportable
import java.time.Instant
import java.util.concurrent.ConcurrentHashMap

/**
 * A snapshot containing information of [node] collected at [instant].
 *
 * @property[node]                      the node the snapshot was taken of.
 * @property[instant]                   The [Instant] the [NodeSnapshot] was taken.
 * @property[numIncomingFlows]          The number of incoming flows at the instant the snapshot is taken.
 * @property[numOutgoingFlows]          The number of outgoing flows at the instant the snapshot was taken.
 * @property[numGeneratingFlows]         The number of flows that are being generated by the node at the instant the snapshot was taken.
 * @property[numConsumedFlows]          The number of flows that are being consumed by the node at the instant the snapshot was taken.
 * @property[currMinFlowTputPerc]       The lowest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currMaxFlowTputPerc]       The highest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currAvrgFlowTputPerc]      The average throughput percentage of all the flows transiting through the node at the instant the snapshot was taken.
 * @property[currNodePortUsageAllPorts] The utilization of all ports of the node at the instant the snapshot was taken, as the sum of used bws divided by the sum of the max bws.
 * @property[avrgPwrUseOverTime]        The average power usage of the node, from the instant the node was started until the instant the snapshot was taken.
 * @property[currPwrUse]                The power usage at the instant the snapshot was taken.
 * @property[totEnConsumed]             The energy consumed from the instant the node was started until the instant the snapshot was taken.
 * @property[currNodeTputAllFlows]      The total data-rate transiting through the node at the instant the snapshot was taken.
 * @property[currNodeTputPercAllFlows]  The total throughput percentage of all flows transiting through the node at the instant the snapshot was taken.
 *
 */
public class NodeSnapshot internal constructor(
    internal val node: Node,
    public val instant: Instant,
    public val numIncomingFlows: Int,
    public val numOutgoingFlows: Int,
    public val numGeneratingFlows: Int,
    public val numConsumedFlows: Int,
    public val currMinFlowTputPerc: Percentage?,
    public val currMaxFlowTputPerc: Percentage?,
    public val currAvrgFlowTputPerc: Percentage?,
    public val currNodePortUsageAllPorts: Percentage,
    public val avrgPwrUseOverTime: Power,
    public val currPwrUse: Power,
    public val totEnConsumed: Energy,
    public val currNodeTputAllFlows: DataRate,
    public val currNodeTputPercAllFlows: Percentage?,
) : Snapshot<NodeSnapshot>(), Exportable {
    override val dfltColWidth: Int = 27

    public val nodeId: NodeId = node.id

    /**
     * @param[flags]    flags representing which property
     * need to be included in the formatted string.
     * @return the formatted string representing the snapshot information,
     * as either 1 or 2 lines with a column for each property.
     */
    override fun fmt(flags: Flags<NodeSnapshot>): String {
        val headersLine = flags.ifSet(HDR, dflt = "") { fmtHdr(flags) }

        val secondLine =
            buildString {
                appendPad("| $node")
                flags.ifSet(INSTANT) { appendPad(instant, pad = 30) }
                flags.ifSet(NUM_FLOWS_IN) { appendPad(numIncomingFlows) }
                flags.ifSet(NUM_FLOWS_OUT) { appendPad(numOutgoingFlows) }
                flags.ifSet(NUM_GEN_FLOWS) { appendPad(numGeneratingFlows) }
                flags.ifSet(NUM_CONS_FLOWS) { appendPad(numConsumedFlows) }
                flags.ifSet(MIN_TPUT_PERC) { appendPad(currMinFlowTputPerc?.fmtValue("%.2f")) }
                flags.ifSet(MAX_TPUT_PERC) { appendPad(currMaxFlowTputPerc?.fmtValue("%.2f")) }
                flags.ifSet(AVRG_TPUT_PERC) { appendPad(currAvrgFlowTputPerc?.fmtValue("%.2f")) }
                flags.ifSet(
                    TOT_NODE_THROUGHPUT,
                ) { appendPad("${currNodeTputAllFlows.fmtValue("%.5f")} (${currNodeTputPercAllFlows?.fmtValue("%.1f") ?: "N/A"})") }
                flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad(currNodePortUsageAllPorts.fmtValue("%.5f")) }
                flags.ifSet(CURR_PWR_USE) { appendPad(currPwrUse.fmtValue("%.5f")) }
                flags.ifSet(AVRG_PWR_USE) { appendPad(avrgPwrUseOverTime.fmtValue("%.5f")) }
                flags.ifSet(EN_CONSUMED) { appendPad(totEnConsumed.fmtValue("%.5f")) }
            }

        return headersLine + secondLine
    }

    /**
     * @return formatted [String] line containing all the headers
     * of the fields associated with the flags [flags]. The [HDR] flags is ignored.
     */
    public override fun fmtHdr(flags: Flags<NodeSnapshot>): String =
        buildString {
            appendPad("| node")
            flags.ifSet(INSTANT) { appendPad("instant", pad = 30) }
            flags.ifSet(NUM_FLOWS_IN) { appendPad("flows in") }
            flags.ifSet(NUM_FLOWS_OUT) { appendPad("flows out") }
            flags.ifSet(NUM_GEN_FLOWS) { appendPad("generating n flows") }
            flags.ifSet(NUM_CONS_FLOWS) { appendPad("consuming n flows") }
            flags.ifSet(MIN_TPUT_PERC) { appendPad("curr min flow tput %") }
            flags.ifSet(MAX_TPUT_PERC) { appendPad("curr max flow tput %") }
            flags.ifSet(AVRG_TPUT_PERC) { appendPad("curr avrg flow tput %") }
            flags.ifSet(TOT_NODE_THROUGHPUT) { appendPad("curr tput (all flows) (%)") }
            flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad("curr node port usage %") }
            flags.ifSet(CURR_PWR_USE) { appendPad("curr pwr use") }
            flags.ifSet(AVRG_PWR_USE) { appendPad("avrg pwr over time") }
            flags.ifSet(EN_CONSUMED) { appendPad("tot energy cons") }
            appendLine()
        }

    override fun toString(): String = "[NodeSnapshot: id=$nodeId, timestamp=$instant]"

    public companion object {
        /**
         * The [Instant] the [NodeSnapshot] was taken.
         */
        public val INSTANT: Flag<NodeSnapshot> = Flag()

        /**
         * The number of flows transiting through the node at the instant the snapshot is taken.
         */
        public val NUM_FLOWS_IN: Flag<NodeSnapshot> = Flag()

        /**
         * The number of outgoing flows at the instant the snapshot was taken.
         */
        public val NUM_FLOWS_OUT: Flag<NodeSnapshot> = Flag()

        /**
         * The number of flows that are being generated by the node at the instant the snapshot was taken.
         */
        public val NUM_GEN_FLOWS: Flag<NodeSnapshot> = Flag()

        /**
         * The number of flows that are being consumed by the node at the instant the snapshot was taken.
         */
        public val NUM_CONS_FLOWS: Flag<NodeSnapshot> = Flag()

        /**
         * The lowest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public val MIN_TPUT_PERC: Flag<NodeSnapshot> = Flag()

        /**
         * The highest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public val MAX_TPUT_PERC: Flag<NodeSnapshot> = Flag()

        /**
         * The average throughput percentage of all the flows transiting through
         * the node at the instant the snapshot was taken.
         */
        public val AVRG_TPUT_PERC: Flag<NodeSnapshot> = Flag()

        /**
         * The utilization of all ports of the node at the instant the snapshot was taken,
         * as the sum of used bws divided by the sum of the max bws.
         */
        public val TOT_NODE_PORT_USAGE: Flag<NodeSnapshot> = Flag()

        /**
         * The power usage at the instant the snapshot was taken.
         */
        public val CURR_PWR_USE: Flag<NodeSnapshot> = Flag()

        /**
         * The average power usage of the node, from the instant the node
         * was started until the instant the snapshot was taken.
         */
        public val AVRG_PWR_USE: Flag<NodeSnapshot> = Flag()

        /**
         * The energy consumed from the instant the node was
         * started until the instant the snapshot was taken.
         */
        public val EN_CONSUMED: Flag<NodeSnapshot> = Flag()

        /**
         * The total data-rate transiting through the node at the instant the snapshot was taken.
         */
        public val TOT_NODE_THROUGHPUT: Flag<NodeSnapshot> = Flag()

        /**
         * Flag that adds a line to the formatted snapshot string with the fields headers.
         */
        public val HDR: Flag<NodeSnapshot> = Flag()

        /**
         * "Flag" that includes all the other flags except [HDR].
         */
        public val ALL_NO_HDR: Flags<NodeSnapshot> = Flags.all<NodeSnapshot>() - HDR

        private val cache = ConcurrentHashMap<NodeId, NodeSnapshot>()

        /**
         * Retrieves a snapshot of [this].
         * @param[instant]              the instant of the snapshot (needs to be provided externally).
         * @param[withStableNetwork]    if `true` waits until the network is stable to take the
         * snapshot (and throws if network becomes unstable while computing it).
         * @param[noCache]              if `true` prevents the use of cache. Cache use needs to
         * be avoided when the timestamp of the snapshot is the same but events have been processed at this instant.
         */
        internal fun Node.snapshot(
            instant: Instant,
            withStableNetwork: Network? = null,
            noCache: Boolean = false,
        ): NodeSnapshot {
            // If snapshot with same timestamp in cache
            if (noCache.not())
                {
                    cache[id]?.let {
                        if (it.instant == instant) return it
                    }
                }

            withStableNetwork?.let {
                runBlocking {
                    it.awaitStability()
                    it.validator.checkIsStableWhile { snapshot(instant = instant) }
                }
            }

            val fh: FlowHandler = this.flowHandler
            val flows: List<OutFlow> = fh.nodeFlowTracker[AllByUnsatisfaction]
            val totNodeTput: DataRate = DataRate.ofKbps(flows.sumOf { it.totRateOut.toKbps() })

            return NodeSnapshot(
                node = this,
                instant = instant,
                numIncomingFlows = fh.consumingFlows.size + fh.outgoingFlows.size - fh.generatingFlows.size,
                numOutgoingFlows = fh.outgoingFlows.size,
                numGeneratingFlows = fh.generatingFlows.size,
                numConsumedFlows = fh.consumingFlows.size,
                currMinFlowTputPerc = flows.firstOrNull()?.let { it.totRateOut roundedPercentageOf it.demand },
                currMaxFlowTputPerc = flows.lastOrNull()?.let { it.totRateOut roundedPercentageOf it.demand },
                currAvrgFlowTputPerc =
                    let {
                        if (flows.isEmpty()) {
                            null
                        } else {
                            flows.sumOfUnit { it.totRateOut roundedPercentageOf it.demand } / flows.size
                        }
                    },
                currNodeTputPercAllFlows =
                    let {
                        if (flows.isEmpty()) {
                            null
                        } else {
                            flows.sumOf { it.totRateOut.toKbps() } roundedPercentageOf flows.sumOf { it.demand.toKbps() }
                        }
                    },
                currPwrUse = (this as? EnergyConsumer<*>)?.enMonitor?.currPwrUsage ?: Power.ZERO,
                avrgPwrUseOverTime = (this as? EnergyConsumer<*>)?.enMonitor?.avrgPwrUsage ?: Power.ZERO,
                totEnConsumed = (this as? EnergyConsumer<*>)?.enMonitor?.totEnConsumpt ?: Energy.ZERO,
                currNodeTputAllFlows = totNodeTput,
                currNodePortUsageAllPorts = totNodeTput roundedPercentageOf ports.sumOfUnit { it.maxSpeed },
            ).also { cache[id] = it }
        }

        /**
         * Retrieves the [NodeSnapshot] of node with id [nodeId] if present in the network.
         */
        public fun NetworkController.snapshotOf(nodeId: NodeId): NodeSnapshot? =
            network.nodesById[nodeId]?.snapshot(currentInstant, withStableNetwork = network)
    }
}
