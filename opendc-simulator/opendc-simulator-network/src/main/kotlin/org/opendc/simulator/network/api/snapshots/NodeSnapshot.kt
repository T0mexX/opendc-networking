package org.opendc.simulator.network.api.snapshots

import kotlinx.coroutines.runBlocking
import org.opendc.simulator.network.api.NetworkController
import org.opendc.simulator.network.api.NodeId
import org.opendc.simulator.network.components.Network
import org.opendc.simulator.network.components.Node
import org.opendc.simulator.network.energy.EnergyConsumer
import org.opendc.simulator.network.export.Exportable
import org.opendc.simulator.network.flow.FlowHandler
import org.opendc.simulator.network.flow.OutFlow
import org.opendc.simulator.network.flow.tracker.AllByUnsatisfaction
import org.opendc.simulator.network.units.DataRate
import org.opendc.simulator.network.units.Energy
import org.opendc.simulator.network.units.Power
import org.opendc.simulator.network.utils.Flag
import org.opendc.simulator.network.utils.Flags
import org.opendc.simulator.network.utils.ratioToPerc
import org.opendc.simulator.network.utils.roundToIfInRange
import java.time.Instant

/**
 * A snapshot containing information of [node] collected at [instant].
 *
 * @property[node]                      the node the snapshot was taken of.
 * @property[instant]                   The [Instant] the [NodeSnapshot] was taken.
 * @property[numIncomingFlows]          The number of incoming flows at the instant the snapshot is taken.
 * @property[numOutgoingFlows]          The number of outgoing flows at the instant the snapshot was taken.
 * @property[numGeneratedFlows]         The number of flows that are being generated by the node at the instant the snapshot was taken.
 * @property[numConsumedFlows]          The number of flows that are being consumed by the node at the instant the snapshot was taken.
 * @property[currMinFlowTputPerc]       The lowest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currMaxFlowTputPerc]       The highest throughput percentage among all the flows transiting through the node at the instant the snapshot was taken, or `null` if not applicable.
 * @property[currAvrgFlowTputPerc]      The average throughput percentage of all the flows transiting through the node at the instant the snapshot was taken.
 * @property[currNodePortUsageAllPorts] The utilization of all ports of the node at the instant the snapshot was taken, as the sum of used bws divided by the sum of the max bws.
 * @property[avrgPwrUseOverTime]        The average power usage of the node, from the instant the node was started until the instant the snapshot was taken.
 * @property[currPwrUse]                The power usage at the instant the snapshot was taken.
 * @property[totEnConsumed]             The energy consumed from the instant the node was started until the instant the snapshot was taken.
 * @property[currNodeTputAllFlows]      The total data-rate transiting through the node at the instant the snapshot was taken.
 * @property[currNodeTputPercAllFlows]  The total throughput percentage of all flows transiting through the node at the instant the snapshot was taken.
 *
 */
public class NodeSnapshot internal constructor(
    internal val node: Node,
    public val instant: Instant,
    public val numIncomingFlows: Int,
    public val numOutgoingFlows: Int,
    public val numGeneratedFlows: Int,
    public val numConsumedFlows: Int,
    public val currMinFlowTputPerc: Double?,
    public val currMaxFlowTputPerc: Double?,
    public val currAvrgFlowTputPerc: Double,
    public val currNodePortUsageAllPorts: Double,
    public val avrgPwrUseOverTime: Power,
    public val currPwrUse: Power,
    public val totEnConsumed: Energy,
    public val currNodeTputAllFlows: DataRate,
    public val currNodeTputPercAllFlows: Double,
): Snapshot<NodeSnapshot>(), Exportable<NodeSnapshot> {

    override val dfltColWidth: Int = 27

    public val nodeId: NodeId = node.id

    /**
     * @param[flags]    flags representing which property
     * need to be included in the formatted string.
     * @return          the formatted string representing the snapshot information,
     * as either 1 or 2 lines with a column for each property.
     */
    override fun fmt(flags: Flags<NodeSnapshot>): String {

        val headersLine = flags.ifSet(HDR, dflt = "") { fmtHdr(flags) }

        val secondLine = buildString {
            appendPad("| $node")
            flags.ifSet(INSTANT) { appendPad(instant, pad = 30) }
            flags.ifSet(NUM_FLOWS_IN) { appendPad(numIncomingFlows) }
            flags.ifSet(NUM_FLOWS_OUT) { appendPad(numOutgoingFlows) }
            flags.ifSet(NUM_GEN_FLOWS) { appendPad(numGeneratedFlows) }
            flags.ifSet(NUM_CONS_FLOWS) { appendPad(numConsumedFlows) }
            flags.ifSet(MIN_TPUT_PERC) { appendPad(currMinFlowTputPerc?.ratioToPerc("%.2f") ?: "NA") }
            flags.ifSet(MAX_TPUT_PERC) { appendPad(currMaxFlowTputPerc?.ratioToPerc("%.2f") ?: "NA") }
            flags.ifSet(AVRG_TPUT_PERC) { appendPad(if (numOutgoingFlows == 0) "NA" else currAvrgFlowTputPerc.ratioToPerc("%.2f")) }
            flags.ifSet(TOT_NODE_THROUGHPUT) { appendPad("${currNodeTputAllFlows.fmtValue("%.5f")} (${currNodeTputPercAllFlows.ratioToPerc("%.1f")})") }
            flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad(currNodePortUsageAllPorts.ratioToPerc("%.5f")) }
            flags.ifSet(CURR_PWR_USE) { appendPad(currPwrUse.fmtValue("%.5f")) }
            flags.ifSet(AVRG_PWR_USE) { appendPad(avrgPwrUseOverTime.fmtValue("%.5f")) }
            flags.ifSet(EN_CONSUMED) { appendPad(totEnConsumed.fmtValue("%.5f")) }
        }

        return headersLine + secondLine
    }

    /**
     * @return formatted [String] line containing all the headers
     * of the fields associated with the flags [flags]. The [HDR] flags is ignored.
     */
    public override fun fmtHdr(flags: Flags<NodeSnapshot>): String =
        buildString {
            appendPad("| node")
            flags.ifSet(INSTANT) { appendPad("instant", pad = 30) }
            flags.ifSet(NUM_FLOWS_IN) { appendPad("flows in") }
            flags.ifSet(NUM_FLOWS_OUT) { appendPad("flows out") }
            flags.ifSet(NUM_GEN_FLOWS) { appendPad("generating n flows") }
            flags.ifSet(NUM_CONS_FLOWS) { appendPad("consuming n flows") }
            flags.ifSet(MIN_TPUT_PERC) { appendPad("curr min flow tput %") }
            flags.ifSet(MAX_TPUT_PERC) { appendPad("curr max flow tput %") }
            flags.ifSet(AVRG_TPUT_PERC) { appendPad("curr avrg flow tput %") }
            flags.ifSet(TOT_NODE_THROUGHPUT) { appendPad("curr tput (all flows) (%)") }
            flags.ifSet(TOT_NODE_PORT_USAGE) { appendPad("curr node port usage %") }
            flags.ifSet(CURR_PWR_USE) { appendPad("curr pwr use") }
            flags.ifSet(AVRG_PWR_USE) { appendPad("avrg pwr over time") }
            flags.ifSet(EN_CONSUMED) { appendPad("tot energy cons") }
            appendLine()
        }

    override fun toString(): String = "[NodeSnapshot: id=$nodeId, timestamp=$instant]"

    public companion object {

        /**
         * The [Instant] the [NodeSnapshot] was taken.
         */
        public val INSTANT: Flag<NodeSnapshot> = Flag(1)

        /**
         * The number of flows transiting through the node at the instant the snapshot is taken.
         */
        public val NUM_FLOWS_IN: Flag<NodeSnapshot> = Flag(1 shl 1)

        /**
         * The number of outgoing flows at the instant the snapshot was taken.
         */
        public val NUM_FLOWS_OUT: Flag<NodeSnapshot> = Flag(1 shl 2)

        /**
         * The number of flows that are being generated by the node at the instant the snapshot was taken.
         */
        public val NUM_GEN_FLOWS: Flag<NodeSnapshot> = Flag(1 shl 3)

        /**
         * The number of flows that are being consumed by the node at the instant the snapshot was taken.
         */
        public val NUM_CONS_FLOWS: Flag<NodeSnapshot> = Flag(1 shl 4)

        /**
         * The lowest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public val MIN_TPUT_PERC: Flag<NodeSnapshot> = Flag(1 shl 5)

        /**
         * The highest throughput percentage among all the flows transiting
         * through the node at the instant the snapshot was taken.
         */
        public val MAX_TPUT_PERC: Flag<NodeSnapshot> = Flag(1 shl 6)

        /**
         * The average throughput percentage of all the flows transiting through
         * the node at the instant the snapshot was taken.
         */
        public val AVRG_TPUT_PERC: Flag<NodeSnapshot> = Flag(1 shl 7)

        /**
         * The utilization of all ports of the node at the instant the snapshot was taken,
         * as the sum of used bws divided by the sum of the max bws.
         */
        public val TOT_NODE_PORT_USAGE: Flag<NodeSnapshot> = Flag(1 shl 8)

        /**
         * The power usage at the instant the snapshot was taken.
         */
        public val CURR_PWR_USE: Flag<NodeSnapshot> = Flag(1 shl 9)

        /**
         * The average power usage of the node, from the instant the node
         * was started until the instant the snapshot was taken.
         */
        public val AVRG_PWR_USE: Flag<NodeSnapshot> = Flag(1 shl 10)

        /**
         * The energy consumed from the instant the node was
         * started until the instant the snapshot was taken.
         */
        public val EN_CONSUMED: Flag<NodeSnapshot> = Flag(1 shl 11)

        /**
         * The total data-rate transiting through the node at the instant the snapshot was taken.
         */
        public val TOT_NODE_THROUGHPUT: Flag<NodeSnapshot> = Flag(1 shl 14)

        /**
         * Flag that adds a line to the formatted snapshot string with the fields headers.
         */
        public val HDR: Flag<NodeSnapshot> = Flag(1 shl 15)

        /**
         * "Flag" that includes all the other flags except [HDR].
         */
        public val ALL_NO_HDR: Flags<NodeSnapshot> = Flags.all<NodeSnapshot>() -  HDR

        internal fun Node.snapshot(instant: Instant, withStableNetwork: Network? = null): NodeSnapshot {
            withStableNetwork?.let {
                runBlocking {
                    it.awaitStability()
                    it.validator.checkIsStableWhile { snapshot(instant = instant) }
                }
            }

            val fh: FlowHandler = this.flowHandler
            val flows: List<OutFlow> = fh.nodeFlowTracker[AllByUnsatisfaction]

            val totNodeTput: DataRate = DataRate.ofKbps(flows.sumOf { it.totRateOut.toKbps() })
            return NodeSnapshot(
                node = this,
                instant = instant,
                numIncomingFlows = fh.consumedFlows.size + fh.outgoingFlows.size - fh.generatedFlows.size,
                numOutgoingFlows = fh.outgoingFlows.size,
                numGeneratedFlows = fh.generatedFlows.size,
                numConsumedFlows = fh.consumedFlows.size,
                currMinFlowTputPerc = flows.getOrNull(0)?.tPutPerc(),
                currMaxFlowTputPerc = flows.lastOrNull()?.tPutPerc(),
                currAvrgFlowTputPerc = flows.sumOf { it.tPutPerc() } / flows.size,
                currNodeTputPercAllFlows = flows.sumOf { it.totRateOut.toKbps() } / flows.sumOf { it.demand.toKbps() },
                currPwrUse = (this as? EnergyConsumer<*>)?.enMonitor?.currPwrUsage ?: Power.ZERO,
                avrgPwrUseOverTime = (this as? EnergyConsumer<*>)?.enMonitor?.avrgPwrUsage ?: Power.ZERO,
                totEnConsumed = (this as? EnergyConsumer<*>)?.enMonitor?.totEnConsumpt ?: Energy.ZERO,
                currNodeTputAllFlows = totNodeTput,
                currNodePortUsageAllPorts = totNodeTput / DataRate.ofKbps(ports.sumOf { it.maxSpeed.toKbps() })
            )
        }

        public fun NetworkController.snapshotOf(nodeId: NodeId): NodeSnapshot? =
            network.nodes[nodeId]?.snapshot(currentInstant)
    }
}

private fun OutFlow.tPutPerc(): Double =
    (this.totRateOut / this.demand).roundToIfInRange(to = 1.0).let {
        check(it in .0..1.0) { "throughput % should be between 0 and 1 but was ${totRateOut / demand}" }
        it
    }
